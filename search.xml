<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>JVM(一)---JAVA内存结构</title>
      <link href="/JVM/2018/10/28/JVM-%E4%B8%80-JAVA%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.html"/>
      <url>/JVM/2018/10/28/JVM-%E4%B8%80-JAVA%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.html</url>
      <content type="html"><![CDATA[<h3 id="JVM概念"><a href="#JVM概念" class="headerlink" title="JVM概念"></a>JVM概念</h3><h4 id="JDK"><a href="#JDK" class="headerlink" title="JDK:"></a><font color="blue">JDK:</font></h4><p>Java Development ToolKit(Java开发工具包), JDK是整个JAVA的核心，包括了Java运行环境（Java Runtime Envirnment），一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）</p><h4 id="JRE"><a href="#JRE" class="headerlink" title="JRE:"></a><font color="blue">JRE:</font></h4><p>Java Runtime Enviromental(java运行时环境)。也就是我们说的JAVA平台，所有的Java程序都要在JRE下才能运行。包括JVM和JAVA核心类库和支持文件。与JDK相比，它不包含开发工具——编译器、调试器和其它工具。</p><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM:"></a><font color="blue">JVM:</font></h4><p>Java Virtual Mechinal(JAVA虚拟机)。JVM是JRE的一部分，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM 的主要工作是解释自己的指令集（即字节码）并映射到本地的 CPU 的指令集或 OS 的系统调用。Java语言是跨平台运行的，其实就是不同的操作系统，使用不同的JVM映射规则，让其与操作系统无关，完成了跨平台性。JVM 对上层的 Java 源文件是不关心的，它关注的只是由源文件生成的类文件（ class file ）</p><p><img src="http://phajzerxx.bkt.clouddn.com/JVM%E6%A6%82%E5%BF%B5.jpg" width="400" hegiht="300" align="center"></p><h3 id="JVM的内存结构"><a href="#JVM的内存结构" class="headerlink" title="JVM的内存结构"></a>JVM的内存结构</h3><h4 id="一-JAVA内存组成"><a href="#一-JAVA内存组成" class="headerlink" title="一.JAVA内存组成"></a><font color="blue">一.JAVA内存组成</font></h4><p><img src="http://phajzerxx.bkt.clouddn.com/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%843.jpg" width="400" hegiht="300" align="center"></p><p>按照官方的说法：“Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。”“在JVM中堆之外的内存称为非堆内存(Non-heap memory)”。可以看出JVM主要管理两种类型的内存：堆和非堆。简单来说堆就是Java代码可及的内存，是留给开发人员使用的；非堆就是JVM留给 自己用的，所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法 的代码都在非堆内存中。</p><h4 id="二-内存区域结构"><a href="#二-内存区域结构" class="headerlink" title="二.内存区域结构"></a><font color="blue">二.内存区域结构</font></h4><p><img src="http://phajzerxx.bkt.clouddn.com/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.jpg" width="400" hegiht="300" align="center"></p><p>PC寄存器(程序计数器):</p><blockquote><p>是最小的一块内存区域，它的作用是当前线程所执行的字节码的行号指示器，在虚拟机的模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。</p></blockquote><p>Java虚拟机栈:</p><blockquote><p>描述的是java 方法执行的内存模型：每个方法被执行的时候 都会创建一个“栈帧”用于存储局部变量表(包括参数)、操作栈、方法出口等信息。每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。声明周期与线程相同，是线程私有的。<br>局部变量表存放了编译器可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(引用指针，并非对象本身)，其中64位长度的long和double类型的数据会占用2个局部变量的空间，其余数据类型只占1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量是完全确定的，在运行期间栈帧不会改变局部变量表的大小空间。</p></blockquote><p>本地方法栈:</p><blockquote><p>与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的java方法服务，而本地方法栈则是为Native方法服务。</p></blockquote><p>方法区:</p><blockquote><p>也称”永久代” 、“非堆”， 它用于存储虚拟机加载的类信息、常量、静态变量、是各个线程共享的内存区域。默认最小值为16MB，最大值为64MB，可以通过-XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小。<br>运行时常量池：是方法区的一部分，其中的主要内容来自于JVM对Class的加载。<br>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。</p></blockquote><p>堆:</p><blockquote><p>也叫做java 堆、GC堆是java虚拟机所管理的内存中最大的一块内存区域，也是被各个线程共享的内存区域，在JVM启动时创建。该内存区域存放了对象实例及数组(所有new的对象)。其大小通过-Xms(最小值)和-Xmx(最大值)参数设置，-Xms为JVM启动时申请的最小内存，默认为操作系统物理内存的1/64但小于1G，-Xmx为JVM可申请的最大内存，默认为物理内存的1/4但小于1G，默认当空余堆内存小于40%时，JVM会增大Heap到-Xmx指定的大小，可通过-XX:MinHeapFreeRation=来指定这个比列；当空余堆内存大于70%时，JVM会减小heap的大小到-Xms指定的大小，可通过XX:MaxHeapFreeRation=来指定这个比列，对于运行系统，为避免在运行时频繁调整Heap的大小，通常-Xms与-Xmx的值设成一样。</p></blockquote><p>新生代:</p><blockquote><p>程序新创建的对象都是从新生代分配内存，新生代由Eden Space和两块相同大小的Survivor Space(通常又称S0和S1或From和To)构成，可通过-Xmn参数来指定新生代的大小，也可以通过-XX:SurvivorRation来调整Eden Space及Survivor Space的大小。</p></blockquote><p>老年代：</p><blockquote><p>用于存放经过多次新生代GC任然存活的对象，例如缓存对象，新建的对象也有可能直接进入老年代，主要有两种情况：①.大对象，可通过启动参数设置-XX:PretenureSizeThreshold=1024(单位为字节，默认为0)来代表超过多大时就不在新生代分配，而是直接在老年代分配。②.大的数组对象，切数组中无引用外部对象。 老年代所占的内存大小为-Xmx对应的值减去-Xmn对应的值。</p></blockquote><p><img src="http://phajzerxx.bkt.clouddn.com/%E5%A0%86%E7%A9%BA%E9%97%B4.jpg" width="400" hegiht="300" align="center"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Young Generation        即图中的Eden + From Space + To Space</span><br><span class="line">Eden                    存放新生的对象</span><br><span class="line">Survivor Space          有两个，存放每次垃圾回收后存活的对象</span><br><span class="line">Old Generation          Tenured Generation 即图中的Old Space</span><br><span class="line">                        主要存放应用程序中生命周期长的存活对象</span><br></pre></td></tr></table></figure><p>设置参数:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.-Xmn:设置新生代大小 -Xmn10m</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.-XX:NewRatio(Ratio of old/<span class="keyword">new</span> generation sizes): 表示老年代 和 新生代(eden + <span class="number">2</span>s) 的比值; &gt;XX:NewRatio=<span class="number">4</span>, 表示老年代 / 新生代 = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.-XX:SurvivorRatio(Ratio of eden/survivor space size eden区域-XX:SurvivorRatio=<span class="number">8</span>   eden/s = <span class="number">8</span>, 也就是一个s占年轻代的 <span class="number">1</span>/<span class="number">10</span></span><br></pre></td></tr></table></figure><h4 id="加深理解"><a href="#加深理解" class="headerlink" title="加深理解"></a><font color="blue">加深理解</font></h4><p><img src="http://phajzerxx.bkt.clouddn.com/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%842.jpg" width="400" hegiht="300" align="center"></p>]]></content>
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
