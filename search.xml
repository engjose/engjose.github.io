<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>RabbitMQ&lt;二&gt;高级特性</title>
      <link href="/RabbitMQ/2018/11/08/RabbitMQ-%E4%BA%8C-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7.html"/>
      <url>/RabbitMQ/2018/11/08/RabbitMQ-%E4%BA%8C-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7.html</url>
      <content type="html"><![CDATA[<h3 id="如何保证消息100-投递"><a href="#如何保证消息100-投递" class="headerlink" title="如何保证消息100%投递"></a>如何保证消息100%投递</h3><h4 id="什么是可靠性投递"><a href="#什么是可靠性投递" class="headerlink" title="什么是可靠性投递"></a>什么是可靠性投递</h4><p>1.保证消息的成功发出<br>2.保障MQ节点的成功接收<br>3.保证发送端收到Broker(Server)的应答<br>4.完善的消息补偿</p><h4 id="生产端—消息可靠投递-一"><a href="#生产端—消息可靠投递-一" class="headerlink" title="生产端—消息可靠投递(一)"></a>生产端—消息可靠投递(一)</h4><p>1.消息落库,对消息进行打标(性能可能出现瓶颈)</p><p><img src="http://phajzerxx.bkt.clouddn.com/%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%8A%95%E9%80%921.jpg" width="400" hegiht="300" align="center"></p><p>2.消息的延迟投递,做二次确认, 回调检查(减少数据库操作)</p><p><img src="http://phajzerxx.bkt.clouddn.com/%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%8A%95%E9%80%922.jpg" width="400" hegiht="300" align="center"></p><h4 id="消费端—幂等性保证"><a href="#消费端—幂等性保证" class="headerlink" title="消费端—幂等性保证"></a>消费端—幂等性保证</h4><p>消费端幂等,意味着,我们的消息永远不会被消费多次, 只能被消费一次</p><p>1.根据业务产生唯一ID,每次操作前在数据库查询,做幂等处理(高并发下有瓶颈),解决方案:根据ID进行分库分表,进行算法路由<br>2.使用Redis的幂等性</p><h3 id="Confirm确认消息"><a href="#Confirm确认消息" class="headerlink" title="Confirm确认消息"></a>Confirm确认消息</h3><h4 id="RabbitMQ的Confirm机制"><a href="#RabbitMQ的Confirm机制" class="headerlink" title="RabbitMQ的Confirm机制"></a>RabbitMQ的Confirm机制</h4><p>1.消息确认是指生产者投递消息后,如果Broker接收到消息,则会给我们Broker一个应答<br>2.生产者接收到应答之后,用来确认这条消息是否正常的发送到Broker,这种机制也是消息可靠性投递的核心保障</p><p><img src="http://phajzerxx.bkt.clouddn.com/confirm.jpg" width="400" hegiht="300" align="center"></p><h4 id="如何开启Confirm模式"><a href="#如何开启Confirm模式" class="headerlink" title="如何开启Confirm模式"></a>如何开启Confirm模式</h4><p>1.在channel上开启确认模式: channel.confirmSelect();<br>2.在channel上添加监听addConfirmListener,添加成功和失败的返回结果,根据结果对消息进行后续处理</p><p>生产端代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shiguang.training.mq.confirm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConfirmListener;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.shiguang.training.mq.MqFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : JOSE 2018/11/4 10:31 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取channel</span></span><br><span class="line">        Connection connection = MqFactory.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        channel.confirmSelect(); <span class="comment">//指定消息确认模式</span></span><br><span class="line"></span><br><span class="line">        String exchangeName = <span class="string">"test_confirm_exchange"</span>;</span><br><span class="line">        String routingKey = <span class="string">"confirm.save"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        String message = <span class="string">"Confirm RabbitMQ:"</span>;</span><br><span class="line">        channel.basicPublish(exchangeName, routingKey, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加监听</span></span><br><span class="line">        channel.addConfirmListener(<span class="keyword">new</span> ConfirmListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAck</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"ACK"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNack</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"NO ACK"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>消费端代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shiguang.training.mq.confirm;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.QueueingConsumer;</span><br><span class="line"><span class="keyword">import</span> com.shiguang.training.mq.MqFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : JOSE 2018/11/4 10:31 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取channel</span></span><br><span class="line">        Connection connection = MqFactory.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        String routingKey = <span class="string">"confirm.#"</span>;</span><br><span class="line">        String exchangeName = <span class="string">"test_confirm_exchange"</span>;</span><br><span class="line">        String queueName = <span class="string">"test_confirm_queue"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明</span></span><br><span class="line">        channel.exchangeDeclare(exchangeName, <span class="string">"topic"</span>, <span class="keyword">true</span>);</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueBind(queueName, exchangeName, routingKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建消费者</span></span><br><span class="line">        QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置channel param1:队列名称 param2: 自动签收 param3:哪一个消费者</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            <span class="keyword">byte</span>[] body = delivery.getBody();</span><br><span class="line">            System.out.println(<span class="string">"消费端:"</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实验结果:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">消费端:</span><br><span class="line">消费端:Confirm RabbitMQ:</span><br><span class="line"></span><br><span class="line">生产端:</span><br><span class="line">ACK</span><br></pre></td></tr></table></figure></p><h4 id="Return消息机制"><a href="#Return消息机制" class="headerlink" title="Return消息机制"></a>Return消息机制</h4><p>1.Return Listener用于处理一些不可路由的消息<br>2.生产者通过指定一个Exchange &amp;&amp; RoutingKey,把消息送达到某一队列中,然后消费者监听队列,进行消费处理操作<br>3.但是有些时候,我们在发送消息的时候,当前的Exchange不存在,或者指定的RoutingKey找不到,这时候我们就需要监听这种不可达的消息,就叫他Return Listener</p><p>怎么设置:<br>Mandatory:如果为true,则监听器会收到路由不可达的消息,进行后续处理;如果为false,那么broker会自动删除该消息;默认为false</p><p><img src="http://phajzerxx.bkt.clouddn.com/return.jpg" width="400" hegiht="300" align="center"></p><p>生产者:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shiguang.training.mq.returnmsg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> com.shiguang.training.mq.MqFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : JOSE 2018/11/4 10:31 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取channel</span></span><br><span class="line">        Connection connection = MqFactory.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        channel.confirmSelect(); <span class="comment">//指定消息确认模式</span></span><br><span class="line"></span><br><span class="line">        String exchangeName = <span class="string">"test_return_exchange"</span>;</span><br><span class="line">        String routingKey = <span class="string">"return.err"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        String message = <span class="string">"RETURN RabbitMQ:"</span>;</span><br><span class="line">        channel.basicPublish(exchangeName, routingKey, <span class="keyword">true</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加监听</span></span><br><span class="line">        channel.addReturnListener(<span class="keyword">new</span> ReturnListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturn</span><span class="params">(<span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Return"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>消费者:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shiguang.training.mq.returnmsg;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.QueueingConsumer;</span><br><span class="line"><span class="keyword">import</span> com.shiguang.training.mq.MqFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : JOSE 2018/11/4 10:31 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取channel</span></span><br><span class="line">        Connection connection = MqFactory.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        String routingKey = <span class="string">"confirm.#"</span>;</span><br><span class="line">        String exchangeName = <span class="string">"test_return_exchange"</span>;</span><br><span class="line">        String queueName = <span class="string">"test_return_queue"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明</span></span><br><span class="line">        channel.exchangeDeclare(exchangeName, <span class="string">"topic"</span>, <span class="keyword">true</span>);</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueBind(queueName, exchangeName, routingKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建消费者</span></span><br><span class="line">        QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置channel param1:队列名称 param2: 自动签收 param3:哪一个消费者</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            <span class="keyword">byte</span>[] body = delivery.getBody();</span><br><span class="line">            System.out.println(<span class="string">"消费端:"</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实验结果:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">生产者Return监听器:</span><br><span class="line">Return</span><br></pre></td></tr></table></figure></p><h3 id="消费端自定义监听"><a href="#消费端自定义监听" class="headerlink" title="消费端自定义监听"></a>消费端自定义监听</h3><p>之前消费者的监听都是在while循环中, 这种方式肯定不好,接下来我们就使用自定义消息监听机制, 只需要继承DefaultConsumer 就可以</p><p>生产者代码如上:</p><p>消费者:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : JOSE 2018/11/4 10:31 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">DefaultConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new instance and records its association to the passed-in channel.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel the channel to which this consumer is attached</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"--------------------自动监听消息--------------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"consumerTag="</span> + consumerTag);</span><br><span class="line">        System.out.println(<span class="string">"envelope"</span> + envelope);</span><br><span class="line">        System.out.println(<span class="string">"properties"</span> + properties);</span><br><span class="line">        System.out.println(<span class="string">"body"</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取channel</span></span><br><span class="line">        Connection connection = MqFactory.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明一个队列 param1:队列名称 param2:是否持久化 param3:是否独占 param4:是否自动删除 param5:扩展参数</span></span><br><span class="line">        String queueName = <span class="string">"test001"</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置channel param1:队列名称 param2: 自动签收 param3:哪一个消费者</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, <span class="keyword">new</span> Consumer(channel));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实验结果:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">消费端:</span><br><span class="line">--------------------自动监听消息--------------------</span><br><span class="line">consumerTag=amq.ctag-24JkfRzCEXNxeNLZINtZCQ</span><br><span class="line">envelopeEnvelope(deliveryTag=1, redeliver=<span class="literal">false</span>, exchange=, routingKey=test001)</span><br><span class="line">properties<span class="comment">#contentHeader&lt;basic&gt;(content-type=null, content-encoding=null, headers=null, delivery-mode=null, priority=null, correlation-id=null, reply-to=null, expiration=null, message-id=null, timestamp=null, type=null, user-id=null, app-id=null, cluster-id=null)</span></span><br><span class="line">bodyHELLO RabbitMQ:0</span><br></pre></td></tr></table></figure></p><h3 id="消费端如何限流"><a href="#消费端如何限流" class="headerlink" title="消费端如何限流"></a>消费端如何限流</h3><p>1.RabbitMQ提供了一种qos(服务质量保证)功能,在非自动确认的前提下,如果有一定数目的消息(通过consumer || channel设置)未被确认前, 不进行消费新的消息; autoAck一定要设置未false<br>2.在消费端需要设置自动签收为false<br>3.在消费端设置Qos: channel.basicQos(0, 1, false) 三个参数含义: param1-&gt;0不限制消息大小,通常为0, param2-&gt;1表示一条一条的接收消息, param3-&gt;false表示此设置被应用与channel,实在consumer上<br>4.在收到消息消费后,需要手动应答:channel.basicAck(deliverayTag, false) ,param1:消息Tag, param2-&gt;不使用自动签收</p><p>消费者:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">DefaultConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new instance and records its association to the passed-in channel.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel the channel to which this consumer is attached</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(channel);</span><br><span class="line">        <span class="keyword">this</span>.channel = channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"--------------------自动监听消息--------------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"consumerTag="</span> + consumerTag);</span><br><span class="line">        System.out.println(<span class="string">"envelope"</span> + envelope);</span><br><span class="line">        System.out.println(<span class="string">"body"</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">        System.out.println(<span class="string">"properties"</span> + properties);</span><br><span class="line"></span><br><span class="line"><span class="comment">//手动回复</span></span><br><span class="line">        channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取channel</span></span><br><span class="line">        Connection connection = MqFactory.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明</span></span><br><span class="line">        String queueName = <span class="string">"test001"</span>;</span><br><span class="line">        String exChangeName = <span class="string">"msg.limit.ex"</span>;</span><br><span class="line">        String routingKey = <span class="string">"limit.#"</span>;</span><br><span class="line">        channel.exchangeDeclare(exChangeName, <span class="string">"topic"</span>);</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueBind(queueName, exChangeName, routingKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置Qos param1不限制大小, param2一条一条消费 3.不作用channel</span></span><br><span class="line">        channel.basicQos(<span class="number">0</span>, <span class="number">1</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置channel param1:队列名称 param2: 自动签收 param3:哪一个消费者</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">false</span>, <span class="keyword">new</span> Consumer(channel));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="消费端ACK与重回队列"><a href="#消费端ACK与重回队列" class="headerlink" title="消费端ACK与重回队列"></a>消费端ACK与重回队列</h3><p>1.消费端进行消费的时候,如果由于业务异常,我们可以进行日志的记录,然后进行补偿,手动NACK<br>2.由于服务器等宕机,我们就需要手工ACK确保消息消费成功</p><p>消费端的重回队列:<br>1.对没有处理成功的消息,把消息重新投递给Broker<br>2.在实际的场景中一般都会关闭重回队列, 也就是设置为False</p><h3 id="TTL消息-队列"><a href="#TTL消息-队列" class="headerlink" title="TTL消息/队列"></a>TTL消息/队列</h3><p>1.Time To Live,也就是生存时间<br>2.RabbitMQ支持消息的过期时间, 在发消息的时候可以指定,在头信息中指定<br>3.也支持入队列的时间,从消息入队列开始计算,只要超过了队列的超时时间设置,那么消息就会被删除</p><h3 id="死信队列DLX-Dead-Letter-Exchange"><a href="#死信队列DLX-Dead-Letter-Exchange" class="headerlink" title="死信队列DLX: Dead-Letter-Exchange"></a>死信队列DLX: Dead-Letter-Exchange</h3><p>1.当消息在一个队列中变成死信,没有消费者,他可以被重新publish到另外的一个Exchange,这个Exchange就叫做死信队列<br>2.DLX也是一个正常的Exchange,和一般的Exchange没有区别,他能在任何的队列上指定,当设置设置某个队列的属性时,当这个队列上有死信时,RabbitMQ就会自动将这个消息重新发布到死信队列</p><p>产生条件:<br>1.消息被拒绝:(basic.reject/ basic.nack), 并且requeue=false(不进行重回队列)<br>2.消息TTL过期<br>3.队列达到最大长度</p><p>死信队列的设置:<br>1.首先需要设置死信队列的Exchange &amp;&amp; queue<br>2.Exchange: dlx.exchange<br>2.Queue:dlx.queue<br>3.RoutingKey:#<br>4.设置正常的Queue, Exchange, RoutingKey, 只不过在队列上添加arguments.put(‘x-dead-letter-exchange’, ‘dlx.exchange’)</p>]]></content>
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RabbitMQ&lt;一&gt;基本概念 &amp;&amp; 环境安装</title>
      <link href="/RabbitMQ/2018/11/05/RabbitMQ-%E4%B8%80-%E5%88%9D%E8%AF%86.html"/>
      <url>/RabbitMQ/2018/11/05/RabbitMQ-%E4%B8%80-%E5%88%9D%E8%AF%86.html</url>
      <content type="html"><![CDATA[<h3 id="主流消息中间件—ActiveMQ"><a href="#主流消息中间件—ActiveMQ" class="headerlink" title="主流消息中间件—ActiveMQ"></a>主流消息中间件—ActiveMQ</h3><p>基本介绍:<br>1.ActiveMQ是Apache出品,最流行的,能力强劲的开源消息总线,完全支持JMS规范<br>2.有丰富的API在中小型公司比较流行<br>3.性能不是非常好</p><p>两种模型:</p><p><img src="http://phajzerxx.bkt.clouddn.com/ActiveMQ%E6%9E%B6%E6%9E%84.jpg" width="400" hegiht="300" align="center"></p><h3 id="主流消息中间件—KAFKA"><a href="#主流消息中间件—KAFKA" class="headerlink" title="主流消息中间件—KAFKA"></a>主流消息中间件—KAFKA</h3><p>基本介绍:<br>1.KAFKA是LinkedIn开源的分布式发布—订阅消息系统,目前归属于Apache顶级项目<br>2.Kafka主要基于pull的模式来处理消息消费,追求吞吐量,一开始就是用于日志的收集和传输<br>3.不支持事务, 对消息的重复, 丢失, 错误没有严格要求, 适合大量数据收集服务,采用内存存储</p><p>模型</p><p><img src="http://phajzerxx.bkt.clouddn.com/Kafk%E6%9E%B6%E6%9E%84.jpg" width="400" hegiht="300" align="center"></p><h3 id="主流消息中间件—RabbitMQ"><a href="#主流消息中间件—RabbitMQ" class="headerlink" title="主流消息中间件—RabbitMQ"></a>主流消息中间件—RabbitMQ</h3><p>1.RabbitMQ是采用Erlang语言开发,基于AMQP协议实现<br>2.面向消息,队列,路由,可靠,安全<br>3.对数据的一致性, 可靠性, 稳定性要求很高, 对吞吐量要求其次, 但是比ActiveMQ</p><p>模型</p><p><img src="http://phajzerxx.bkt.clouddn.com/rabbitmq%E6%A8%A1%E5%9E%8B.jpg" width="400" hegiht="300" align="center"></p><h3 id="AMQP协议"><a href="#AMQP协议" class="headerlink" title="AMQP协议:"></a>AMQP协议:</h3><p>AMQP协议是一个二进制协议,是一个统一提供消息服务的应用层标准高级协议</p><p>协议模型:</p><p><img src="http://phajzerxx.bkt.clouddn.com/AMQP%E5%8D%8F%E8%AE%AE.jpg" width="400" hegiht="300" align="center"></p><p>AMQP基本概念:<br>1.Server:又称Broker,接收客户端的连接,实现AMQP实体服务</p><p>2.Connection:连接,应用程序与Broker的网络连接</p><p>3.Channel:网络信道,几乎所有的操作都在Channel中进行,Channel是进行消息读写的通道,客户端可以建立多个Channel,每个Channel代表一个会话任务</p><p>4.Message:消息, 服务和应用之间传输的数据,由Properties &amp;&amp; body组成. Properties对消息可以修饰,比如消息的优先级,延迟等高级特性; body则是消息的实体</p><p>5.Virtualhost:虚拟主机,用于进行逻辑隔离,最上层的消息路由. 一个Virtual Host里面有若干个Exchange &amp;&amp; Queue, 但是同一个Virtual Host里面不能有相同的Exchange || Queue</p><p>6.Exchange:交换机, 接收消息,根据路由键转发消息到不同的队列</p><p>7.Binding:Exchange 与Queue之间的虚拟连接, Binding中可以包含Routing Key</p><p>8.Routing key:一个路由的规则,虚拟机可以用来确定如何路由到特定消息</p><p>9:Queue:也称之为Message Queue, 消息队列, 保存消息并将它们转发给消费者</p><h3 id="初识RabbitMQ"><a href="#初识RabbitMQ" class="headerlink" title="初识RabbitMQ"></a>初识RabbitMQ</h3><p>为什么高性能:<br>1.Erlang语言,最初使用于交换机架构领域模式,这样使得RabbitMQ在Broker数据交互的性能是非常优秀的<br>2.Erlang语言的特点:有着和原生Socket一样的延迟</p><p>RabbitMQ架构图:</p><p><img src="http://phajzerxx.bkt.clouddn.com/RabbitMQ%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" width="400" hegiht="300" align="center"></p><p>RabbitMQ消息流转图</p><p><img src="http://phajzerxx.bkt.clouddn.com/Rabbitmq%E6%B6%88%E6%81%AF%E6%B5%81%E8%BD%AC.jpg" width="400" hegiht="300" align="center"></p><h3 id="RabbitMQ的环境安装-centos-7"><a href="#RabbitMQ的环境安装-centos-7" class="headerlink" title="RabbitMQ的环境安装(centos 7)"></a>RabbitMQ的环境安装(centos 7)</h3><p>1.官网地址: <a href="http://www.rabbitmq.com/" target="_blank" rel="noopener">http://www.rabbitmq.com/</a><br>2.下载erlang:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0.准备,如果centos没有的话</span></span><br><span class="line">yum install </span><br><span class="line">build-essential openssl openssl-devel unixODBC unixODBC-devel </span><br><span class="line">make gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc xz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.下载资源</span></span><br><span class="line">wget www.rabbitmq.com/releases/erlang/erlang-18.3-1.el7.centos.x86_64.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.下载rabbitmq</span></span><br><span class="line">wget www.rabbitmq.com/releases/rabbitmq-server/v3.6.5/rabbitmq-server-3.6.5-1.noarch.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.下载socat</span></span><br><span class="line">wget http://repo.iotti.biz/CentOS/7/x86_64/socat-1.7.3.2-5.el7.lux.x86_64.rpm</span><br></pre></td></tr></table></figure><p>3.安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.erlang</span></span><br><span class="line">rpm -ivh erlang-18.3-1.el7.centos.x86_64.rpm  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.安装socat秘钥包</span></span><br><span class="line">rpm -ivh socat-1.7.3.2-5.el7.lux.x86_64.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.安装rabbitmq</span></span><br><span class="line">rpm -ivh rabbitmq-server-3.6.5-1.noarch.rpm </span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.修改配置文件</span></span><br><span class="line">/usr/lib/rabbitmq/lib/rabbitmq_server-3.6.5/ebin/rabbit.app</span><br><span class="line">&#123;loopback_users, [&lt;&lt;<span class="string">"guest"</span>&gt;&gt;]&#125; 改为 &#123;loopback_users, [guest]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.启动rabbitmq</span></span><br><span class="line">rabbitmq-server start &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 关闭rabbitmq</span></span><br><span class="line">rabbitmq-server stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.查看默认安装的插件</span></span><br><span class="line">rabbitmq-plugins list</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8. 启动管理界面</span></span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9. 访问服务(15672是管控台的端口)</span></span><br><span class="line">http://ip:15672/</span><br><span class="line">用户名 &amp;&amp; 密码都输入: guest 因为之前修改过loopback_users</span><br></pre></td></tr></table></figure><h3 id="RabbitMQ的基本命令"><a href="#RabbitMQ的基本命令" class="headerlink" title="RabbitMQ的基本命令"></a>RabbitMQ的基本命令</h3><p>启动停止命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.启动服务</span></span><br><span class="line">rabbitmqctl start_app</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.关闭服务</span></span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.查看节点状态</span></span><br><span class="line">rabbitmactl status</span><br></pre></td></tr></table></figure></p><p>用户命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.查看用户</span></span><br><span class="line">rabbitmqctl list_users </span><br><span class="line"></span><br><span class="line"><span class="comment">#2.添加用户</span></span><br><span class="line">rabbitmqctl add_user root(username) root(password)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.删除用户</span></span><br><span class="line">rabbitmqctl delete_user username</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.列出用户的权限</span></span><br><span class="line">rabbitmqctl list_user_permissions guest </span><br><span class="line"></span><br><span class="line"><span class="comment">#5.修改用户密码</span></span><br><span class="line">rabbitmqctl change_password username password(new)</span><br></pre></td></tr></table></figure></p><p>虚拟主机命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.列出虚拟主机</span></span><br><span class="line">rabbitmqctl list_vhosts </span><br><span class="line"></span><br><span class="line"><span class="comment">#2.添加虚拟主机</span></span><br><span class="line">rabbitmqctl add_vhost vhost_path</span><br><span class="line"></span><br><span class="line">3.查看虚拟主机的权限</span><br><span class="line">rabbitmqctl list_permissions -p /(vhost_path) </span><br><span class="line"></span><br><span class="line">4.删除虚拟主机</span><br><span class="line">rabbitmqctl delete_vhost (vhost_path)</span><br></pre></td></tr></table></figure></p><p>队列命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.查看队列</span></span><br><span class="line">rabbitmqctl list_queues </span><br><span class="line"></span><br><span class="line"><span class="comment">#2.移除所有消息(必须在rabbitmqctl stop_app之后才能清除)</span></span><br><span class="line">rabbitmqctl reset</span><br></pre></td></tr></table></figure></p><p>高级操作<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.加入集群命令</span></span><br><span class="line">rabbitmqctl join_cluster &lt;clusternode&gt; [--ram(内存)]</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.查看集群状态</span></span><br><span class="line">rabbitmqctl cluster_status</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.修改集群消息的存储模式</span></span><br><span class="line">rabbitmqctl change_cluster_node_type disc(硬盘) | ram(内存)</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.移除节点</span></span><br><span class="line">rabbitmqctl forget_cluster_node [--offline]</span><br></pre></td></tr></table></figure></p><h3 id="RabbitMQ管控台"><a href="#RabbitMQ管控台" class="headerlink" title="RabbitMQ管控台"></a>RabbitMQ管控台</h3><p>Overview</p><p><img src="http://phajzerxx.bkt.clouddn.com/%E7%AE%A1%E6%8E%A7%E5%8F%B01.jpg" width="400" hegiht="300" align="center"></p><p>Connection:</p><p><img src="http://phajzerxx.bkt.clouddn.com/%E7%AE%A1%E6%8E%A7%E5%8F%B02.jpg" width="400" hegiht="300" align="center"></p><p>Channel</p><p><img src="http://phajzerxx.bkt.clouddn.com/%E7%AE%A1%E6%8E%A7%E5%8F%B03.jpg" width="400" hegiht="300" align="center"></p><p>Exchange:</p><p><img src="http://phajzerxx.bkt.clouddn.com/%E7%AE%A1%E6%8E%A7%E5%8F%B04.jpg" width="400" hegiht="300" align="center"></p><p>Queue:</p><p><img src="http://phajzerxx.bkt.clouddn.com/%E7%AE%A1%E6%8E%A7%E5%8F%B05.jpg" width="400" hegiht="300" align="center"></p><p>Admin</p><p><img src="http://phajzerxx.bkt.clouddn.com/%E7%AE%A1%E6%8E%A7%E5%8F%B06.jpg" width="400" hegiht="300" align="center"></p><h3 id="生产者消费者模型构建"><a href="#生产者消费者模型构建" class="headerlink" title="生产者消费者模型构建"></a>生产者消费者模型构建</h3><p>pom依赖<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;3.6.5&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>获取连接工厂<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shiguang.training.mq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : JOSE 2018/11/4 10:37 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"ip"</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个连接</span></span><br><span class="line">        <span class="keyword">return</span> factory.newConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Channel channel, Connection connection)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>生产者代码:</p><blockquote><p>1.channel.basicPublish(“”, “test001”, null, message.getBytes()); param1指定exchange, 如果不指定,RabbitMQ会走默认的exchange(AMQP default),会把消息投递到和routing key一样的队列中, param2:指定routing key</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shiguang.training.mq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : JOSE 2018/11/4 10:31 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取channel</span></span><br><span class="line">        Connection connection = MqFactory.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            String message = <span class="string">"HELLO RabbitMQ:"</span> + i;</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>, <span class="string">"test001"</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        MqFactory.close(channel, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者:</p><blockquote><p>1.消费者中需要指定队列,生产者中不需要指定,如果生产者先发送消息,消费者没有启动的时候,队列未创建, 这时候消息会被存储在rabbitmq服务器中等待消费<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shiguang.training.mq;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.QueueingConsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : JOSE 2018/11/4 10:31 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取channel</span></span><br><span class="line">        Connection connection = MqFactory.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明一个队列 param1:队列名称 param2:是否持久化 param3:是否独占 param4:是否自动删除 param5:扩展参数</span></span><br><span class="line">        String queueName = <span class="string">"test001"</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建消费者</span></span><br><span class="line">        QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置channel param1:队列名称 param2: 自动签收 param3:哪一个消费者</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            <span class="keyword">byte</span>[] body = delivery.getBody();</span><br><span class="line">            System.out.println(<span class="string">"消费端:"</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>实验结果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 消费端</span></span><br><span class="line">消费端:HELLO RabbitMQ:0</span><br><span class="line">消费端:HELLO RabbitMQ:1</span><br><span class="line">消费端:HELLO RabbitMQ:2</span><br><span class="line">消费端:HELLO RabbitMQ:3</span><br><span class="line">消费端:HELLO RabbitMQ:4</span><br></pre></td></tr></table></figure></p><p>先启动生产者, 消费者没启动时, 消息积压 ready:5, total:5</p><p><img src="http://phajzerxx.bkt.clouddn.com/%E6%B6%88%E6%81%AF%E7%A7%AF%E5%8E%8B.jpg" width="400" hegiht="300" align="center"></p><p>启动消费者后, 消息被消费:</p><p><img src="http://phajzerxx.bkt.clouddn.com/%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9.jpg" width="400" hegiht="300" align="center"></p><h3 id="Exchange-交换机"><a href="#Exchange-交换机" class="headerlink" title="Exchange 交换机"></a>Exchange 交换机</h3><p>Exchange负责接收消息,并根据路由键转发消息所绑定的队列</p><p><img src="http://phajzerxx.bkt.clouddn.com/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%A8%A1%E5%9E%8B.jpg" width="400" hegiht="300" align="center"></p><p>交换机的属性:</p><blockquote><p>1.name:交换机名称<br>2.type:交换机的类型,direct,topic,fanout, headers<br>3.durability:是否需要持久化, true表示持久化<br>4.auto delete:当最后一个绑定在Exchange上的队列删除时,自动删除该Exchange<br>5.arguments:扩展参数</p></blockquote><h3 id="交换机的类型—Direct-Exchange"><a href="#交换机的类型—Direct-Exchange" class="headerlink" title="交换机的类型—Direct Exchange"></a>交换机的类型—Direct Exchange</h3><blockquote><p>1.所有发送到direct exchange的消息被转发到,Routing Key中指定的Queue<br>2.Direct可以使用RabbitMQ自带的Exchange(default Exchange) ,所以不需要将Exchange进行任何的绑定,Routing Key必须完全匹配才会被队列接收</p></blockquote><p><img src="http://phajzerxx.bkt.clouddn.com/direct.jpg" width="400" hegiht="300" align="center"></p><h3 id="交换机的类型—Topic-Exchange"><a href="#交换机的类型—Topic-Exchange" class="headerlink" title="交换机的类型—Topic Exchange"></a>交换机的类型—Topic Exchange</h3><blockquote><p>1.Exchange将Routing Key和Topic进行模糊匹配,此时队列需要一个Topic<br>2.”#”:匹配一个或者多个词<br>3.”*”:匹配一个词</p></blockquote><p><img src="http://phajzerxx.bkt.clouddn.com/topic.jpg" width="400" hegiht="300" align="center"></p><h3 id="交换机的类型—Fanout-Exchange"><a href="#交换机的类型—Fanout-Exchange" class="headerlink" title="交换机的类型—Fanout Exchange"></a>交换机的类型—Fanout Exchange</h3><blockquote><p>1.不处理路由键,只需要简单的将队列绑定到交换机上, 不处理路由键<br>2.发送到交换机上的消息,都会被转发到与该交换机绑定的所有队列上<br>3.fanout交换机转发消息是最快的</p></blockquote><p><img src="http://phajzerxx.bkt.clouddn.com/fanout.jpg" width="400" hegiht="300" align="center"></p><h3 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h3><blockquote><p>1.Exchange &amp;&amp; Queue之间的连接关系</p></blockquote><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><blockquote><p>1.消息队列, 存储消息<br>2.Durability:是否持久化<br>3.Auto delete:当最后一个监听被移除的时候, 该队列自动删除</p></blockquote><h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><blockquote><p>1.Msg服务器和App之间传送的数据<br>2.本质上就是一段数据, 由Properties &amp;&amp; Payload(body) 组成</p></blockquote><h3 id="虚拟主机Virtual-Host"><a href="#虚拟主机Virtual-Host" class="headerlink" title="虚拟主机Virtual Host"></a>虚拟主机Virtual Host</h3><blockquote><p>1.用于逻辑隔离, 最上层的路由<br>2.一个Virtual Host里面可以有若干个Exchange &amp;&amp; Queue<br>3.同一个Virtual Host里面不可以有相同的Exchange &amp;&amp; Queue</p></blockquote>]]></content>
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM(一)---JAVA内存结构</title>
      <link href="/JVM/2018/10/28/JVM-%E4%B8%80-JAVA%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.html"/>
      <url>/JVM/2018/10/28/JVM-%E4%B8%80-JAVA%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.html</url>
      <content type="html"><![CDATA[<h3 id="JVM概念"><a href="#JVM概念" class="headerlink" title="JVM概念"></a>JVM概念</h3><h4 id="JDK"><a href="#JDK" class="headerlink" title="JDK:"></a><font color="blue">JDK:</font></h4><p>Java Development ToolKit(Java开发工具包), JDK是整个JAVA的核心，包括了Java运行环境（Java Runtime Envirnment），一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）</p><h4 id="JRE"><a href="#JRE" class="headerlink" title="JRE:"></a><font color="blue">JRE:</font></h4><p>Java Runtime Enviromental(java运行时环境)。也就是我们说的JAVA平台，所有的Java程序都要在JRE下才能运行。包括JVM和JAVA核心类库和支持文件。与JDK相比，它不包含开发工具——编译器、调试器和其它工具。</p><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM:"></a><font color="blue">JVM:</font></h4><p>Java Virtual Mechinal(JAVA虚拟机)。JVM是JRE的一部分，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM 的主要工作是解释自己的指令集（即字节码）并映射到本地的 CPU 的指令集或 OS 的系统调用。Java语言是跨平台运行的，其实就是不同的操作系统，使用不同的JVM映射规则，让其与操作系统无关，完成了跨平台性。JVM 对上层的 Java 源文件是不关心的，它关注的只是由源文件生成的类文件（ class file ）</p><p><img src="http://phajzerxx.bkt.clouddn.com/JVM%E6%A6%82%E5%BF%B5.jpg" width="400" hegiht="300" align="center"></p><h3 id="JVM的内存结构"><a href="#JVM的内存结构" class="headerlink" title="JVM的内存结构"></a>JVM的内存结构</h3><h4 id="一-JAVA内存组成"><a href="#一-JAVA内存组成" class="headerlink" title="一.JAVA内存组成"></a><font color="blue">一.JAVA内存组成</font></h4><p><img src="http://phajzerxx.bkt.clouddn.com/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%843.jpg" width="400" hegiht="300" align="center"></p><p>按照官方的说法：“Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。”“在JVM中堆之外的内存称为非堆内存(Non-heap memory)”。可以看出JVM主要管理两种类型的内存：堆和非堆。简单来说堆就是Java代码可及的内存，是留给开发人员使用的；非堆就是JVM留给 自己用的，所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法 的代码都在非堆内存中。</p><h4 id="二-内存区域结构"><a href="#二-内存区域结构" class="headerlink" title="二.内存区域结构"></a><font color="blue">二.内存区域结构</font></h4><p><img src="http://phajzerxx.bkt.clouddn.com/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.jpg" width="400" hegiht="300" align="center"></p><p>PC寄存器(程序计数器):</p><blockquote><p>是最小的一块内存区域，它的作用是当前线程所执行的字节码的行号指示器，在虚拟机的模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。</p></blockquote><p>Java虚拟机栈:</p><blockquote><p>描述的是java 方法执行的内存模型：每个方法被执行的时候 都会创建一个“栈帧”用于存储局部变量表(包括参数)、操作栈、方法出口等信息。每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。声明周期与线程相同，是线程私有的。<br>局部变量表存放了编译器可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(引用指针，并非对象本身)，其中64位长度的long和double类型的数据会占用2个局部变量的空间，其余数据类型只占1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量是完全确定的，在运行期间栈帧不会改变局部变量表的大小空间。</p></blockquote><p>本地方法栈:</p><blockquote><p>与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的java方法服务，而本地方法栈则是为Native方法服务。</p></blockquote><p>方法区:</p><blockquote><p>也称”永久代” 、“非堆”， 它用于存储虚拟机加载的类信息、常量、静态变量、是各个线程共享的内存区域。默认最小值为16MB，最大值为64MB，可以通过-XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小。<br>运行时常量池：是方法区的一部分，其中的主要内容来自于JVM对Class的加载。<br>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。</p></blockquote><p>堆:</p><blockquote><p>也叫做java 堆、GC堆是java虚拟机所管理的内存中最大的一块内存区域，也是被各个线程共享的内存区域，在JVM启动时创建。该内存区域存放了对象实例及数组(所有new的对象)。其大小通过-Xms(最小值)和-Xmx(最大值)参数设置，-Xms为JVM启动时申请的最小内存，默认为操作系统物理内存的1/64但小于1G，-Xmx为JVM可申请的最大内存，默认为物理内存的1/4但小于1G，默认当空余堆内存小于40%时，JVM会增大Heap到-Xmx指定的大小，可通过-XX:MinHeapFreeRation=来指定这个比列；当空余堆内存大于70%时，JVM会减小heap的大小到-Xms指定的大小，可通过XX:MaxHeapFreeRation=来指定这个比列，对于运行系统，为避免在运行时频繁调整Heap的大小，通常-Xms与-Xmx的值设成一样。</p></blockquote><p>新生代:</p><blockquote><p>程序新创建的对象都是从新生代分配内存，新生代由Eden Space和两块相同大小的Survivor Space(通常又称S0和S1或From和To)构成，可通过-Xmn参数来指定新生代的大小，也可以通过-XX:SurvivorRation来调整Eden Space及Survivor Space的大小。</p></blockquote><p>老年代：</p><blockquote><p>用于存放经过多次新生代GC任然存活的对象，例如缓存对象，新建的对象也有可能直接进入老年代，主要有两种情况：①.大对象，可通过启动参数设置-XX:PretenureSizeThreshold=1024(单位为字节，默认为0)来代表超过多大时就不在新生代分配，而是直接在老年代分配。②.大的数组对象，切数组中无引用外部对象。 老年代所占的内存大小为-Xmx对应的值减去-Xmn对应的值。</p></blockquote><p><img src="http://phajzerxx.bkt.clouddn.com/%E5%A0%86%E7%A9%BA%E9%97%B4.jpg" width="400" hegiht="300" align="center"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Young Generation        即图中的Eden + From Space + To Space</span><br><span class="line">Eden                    存放新生的对象</span><br><span class="line">Survivor Space          有两个，存放每次垃圾回收后存活的对象</span><br><span class="line">Old Generation          Tenured Generation 即图中的Old Space</span><br><span class="line">                        主要存放应用程序中生命周期长的存活对象</span><br></pre></td></tr></table></figure><p>设置参数:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.-Xmn:设置新生代大小 -Xmn10m</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.-XX:NewRatio(Ratio of old/<span class="keyword">new</span> generation sizes): 表示老年代 和 新生代(eden + <span class="number">2</span>s) 的比值; &gt;XX:NewRatio=<span class="number">4</span>, 表示老年代 / 新生代 = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.-XX:SurvivorRatio(Ratio of eden/survivor space size eden区域-XX:SurvivorRatio=<span class="number">8</span>   eden/s = <span class="number">8</span>, 也就是一个s占年轻代的 <span class="number">1</span>/<span class="number">10</span></span><br></pre></td></tr></table></figure><h4 id="加深理解"><a href="#加深理解" class="headerlink" title="加深理解"></a><font color="blue">加深理解</font></h4><p><img src="http://phajzerxx.bkt.clouddn.com/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%842.jpg" width="400" hegiht="300" align="center"></p>]]></content>
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
