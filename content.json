{"meta":{"title":"SUPER-JOSE-大叔的技术博客","subtitle":"There is no shortcut is a permanent shortcut","description":"踏踏实实做人,认认真真编程","author":"SUPER-JOSE","url":"http://www.fireworm.online"},"pages":[{"title":"categories","date":"2018-08-03T02:22:21.000Z","updated":"2018-09-18T14:57:11.715Z","comments":true,"path":"categories/index.html","permalink":"http://www.fireworm.online/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2018-08-02T02:16:30.000Z","updated":"2018-08-02T02:16:30.548Z","comments":true,"path":"search/index-2.html","permalink":"http://www.fireworm.online/search/index-2.html","excerpt":"","text":""},{"title":"Search","date":"2018-08-01T15:40:24.000Z","updated":"2018-08-01T15:40:24.169Z","comments":true,"path":"search/index-1.html","permalink":"http://www.fireworm.online/search/index-1.html","excerpt":"","text":""},{"title":"Search","date":"2018-08-01T15:24:29.000Z","updated":"2018-08-02T02:19:07.639Z","comments":true,"path":"search/index.html","permalink":"http://www.fireworm.online/search/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-18T14:23:48.000Z","updated":"2018-09-18T14:23:48.485Z","comments":true,"path":"tags/index-1.html","permalink":"http://www.fireworm.online/tags/index-1.html","excerpt":"","text":""},{"title":"tags","date":"2017-07-10T08:36:26.000Z","updated":"2018-08-03T02:15:06.076Z","comments":true,"path":"tags/index.html","permalink":"http://www.fireworm.online/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"RabbitMQ<一>基本概念 && 环境安装","slug":"RabbitMQ-一-初识","date":"2018-11-05T14:32:38.000Z","updated":"2018-11-05T14:57:57.384Z","comments":true,"path":"RabbitMQ/2018/11/05/RabbitMQ-一-初识.html","link":"","permalink":"http://www.fireworm.online/RabbitMQ/2018/11/05/RabbitMQ-一-初识.html","excerpt":"","text":"主流消息中间件—ActiveMQ基本介绍:1.ActiveMQ是Apache出品,最流行的,能力强劲的开源消息总线,完全支持JMS规范2.有丰富的API在中小型公司比较流行3.性能不是非常好 两种模型: 主流消息中间件—KAFKA基本介绍:1.KAFKA是LinkedIn开源的分布式发布—订阅消息系统,目前归属于Apache顶级项目2.Kafka主要基于pull的模式来处理消息消费,追求吞吐量,一开始就是用于日志的收集和传输3.不支持事务, 对消息的重复, 丢失, 错误没有严格要求, 适合大量数据收集服务,采用内存存储 模型 主流消息中间件—RabbitMQ1.RabbitMQ是采用Erlang语言开发,基于AMQP协议实现2.面向消息,队列,路由,可靠,安全3.对数据的一致性, 可靠性, 稳定性要求很高, 对吞吐量要求其次, 但是比ActiveMQ 模型 AMQP协议:AMQP协议是一个二进制协议,是一个统一提供消息服务的应用层标准高级协议 协议模型: AMQP基本概念:1.Server:又称Broker,接收客户端的连接,实现AMQP实体服务 2.Connection:连接,应用程序与Broker的网络连接 3.Channel:网络信道,几乎所有的操作都在Channel中进行,Channel是进行消息读写的通道,客户端可以建立多个Channel,每个Channel代表一个会话任务 4.Message:消息, 服务和应用之间传输的数据,由Properties &amp;&amp; body组成. Properties对消息可以修饰,比如消息的优先级,延迟等高级特性; body则是消息的实体 5.Virtualhost:虚拟主机,用于进行逻辑隔离,最上层的消息路由. 一个Virtual Host里面有若干个Exchange &amp;&amp; Queue, 但是同一个Virtual Host里面不能有相同的Exchange || Queue 6.Exchange:交换机, 接收消息,根据路由键转发消息到不同的队列 7.Binding:Exchange 与Queue之间的虚拟连接, Binding中可以包含Routing Key 8.Routing key:一个路由的规则,虚拟机可以用来确定如何路由到特定消息 9:Queue:也称之为Message Queue, 消息队列, 保存消息并将它们转发给消费者 初识RabbitMQ为什么高性能:1.Erlang语言,最初使用于交换机架构领域模式,这样使得RabbitMQ在Broker数据交互的性能是非常优秀的2.Erlang语言的特点:有着和原生Socket一样的延迟 RabbitMQ架构图: RabbitMQ消息流转图 RabbitMQ的环境安装(centos 7)1.官网地址: http://www.rabbitmq.com/2.下载erlang: 12345678910111213# 0.准备,如果centos没有的话yum install build-essential openssl openssl-devel unixODBC unixODBC-devel make gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc xz# 1.下载资源wget www.rabbitmq.com/releases/erlang/erlang-18.3-1.el7.centos.x86_64.rpm# 2.下载rabbitmqwget www.rabbitmq.com/releases/rabbitmq-server/v3.6.5/rabbitmq-server-3.6.5-1.noarch.rpm# 3.下载socatwget http://repo.iotti.biz/CentOS/7/x86_64/socat-1.7.3.2-5.el7.lux.x86_64.rpm 3.安装 1234567891011121314151617181920212223242526272829# 1.erlangrpm -ivh erlang-18.3-1.el7.centos.x86_64.rpm # 2.安装socat秘钥包rpm -ivh socat-1.7.3.2-5.el7.lux.x86_64.rpm# 3.安装rabbitmqrpm -ivh rabbitmq-server-3.6.5-1.noarch.rpm # 4.修改配置文件/usr/lib/rabbitmq/lib/rabbitmq_server-3.6.5/ebin/rabbit.app&#123;loopback_users, [&lt;&lt;\"guest\"&gt;&gt;]&#125; 改为 &#123;loopback_users, [guest]&#125;# 5.启动rabbitmqrabbitmq-server start &amp;# 6. 关闭rabbitmqrabbitmq-server stop# 7.查看默认安装的插件rabbitmq-plugins list...# 8. 启动管理界面rabbitmq-plugins enable rabbitmq_management# 9. 访问服务(15672是管控台的端口)http://ip:15672/用户名 &amp;&amp; 密码都输入: guest 因为之前修改过loopback_users RabbitMQ的基本命令启动停止命令12345678#1.启动服务rabbitmqctl start_app#2.关闭服务rabbitmqctl stop_app#3.查看节点状态rabbitmactl status 用户命令1234567891011121314#1.查看用户rabbitmqctl list_users #2.添加用户rabbitmqctl add_user root(username) root(password)#3.删除用户rabbitmqctl delete_user username#4.列出用户的权限rabbitmqctl list_user_permissions guest #5.修改用户密码rabbitmqctl change_password username password(new) 虚拟主机命令1234567891011#1.列出虚拟主机rabbitmqctl list_vhosts #2.添加虚拟主机rabbitmqctl add_vhost vhost_path3.查看虚拟主机的权限rabbitmqctl list_permissions -p /(vhost_path) 4.删除虚拟主机rabbitmqctl delete_vhost (vhost_path) 队列命令12345#1.查看队列rabbitmqctl list_queues #2.移除所有消息(必须在rabbitmqctl stop_app之后才能清除)rabbitmqctl reset 高级操作1234567891011#1.加入集群命令rabbitmqctl join_cluster &lt;clusternode&gt; [--ram(内存)]#2.查看集群状态rabbitmqctl cluster_status#3.修改集群消息的存储模式rabbitmqctl change_cluster_node_type disc(硬盘) | ram(内存)#4.移除节点rabbitmqctl forget_cluster_node [--offline] RabbitMQ管控台Overview Connection: Channel Exchange: Queue: Admin 生产者消费者模型构建pom依赖12345&lt;dependency&gt; &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;amqp-client&lt;/artifactId&gt; &lt;version&gt;3.6.5&lt;/version&gt; &lt;/dependency&gt; 获取连接工厂123456789101112131415161718192021222324252627282930package com.shiguang.training.mq;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import java.io.IOException;import java.util.concurrent.TimeoutException;/** * @author : JOSE 2018/11/4 10:37 PM */public class MqFactory &#123; public static Connection getConnection() throws IOException, TimeoutException &#123; // 创建一个连接工厂 ConnectionFactory factory = new ConnectionFactory(); factory.setHost(\"ip\"); factory.setPort(5672); factory.setVirtualHost(\"/\"); // 创建一个连接 return factory.newConnection(); &#125; public static void close(Channel channel, Connection connection) throws IOException, TimeoutException &#123; channel.close(); connection.close(); &#125;&#125; 生产者代码: 1.channel.basicPublish(“”, “test001”, null, message.getBytes()); param1指定exchange, 如果不指定,RabbitMQ会走默认的exchange(AMQP default),会把消息投递到和routing key一样的队列中, param2:指定routing key 12345678910111213141516171819202122232425262728package com.shiguang.training.mq;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import java.io.IOException;import java.util.concurrent.TimeoutException;/** * @author : JOSE 2018/11/4 10:31 PM */public class Producer &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; // 获取channel Connection connection = MqFactory.getConnection(); Channel channel = connection.createChannel(); // 发送消息 for (int i = 0; i &lt; 5; i++) &#123; String message = \"HELLO RabbitMQ:\" + i; channel.basicPublish(\"\", \"test001\", null, message.getBytes()); &#125; // 关闭连接 MqFactory.close(channel, connection); &#125;&#125; 消费者: 1.消费者中需要指定队列,生产者中不需要指定,如果生产者先发送消息,消费者没有启动的时候,队列未创建, 这时候消息会被存储在rabbitmq服务器中等待消费12345678910111213141516171819202122232425262728293031323334353637package com.shiguang.training.mq;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.QueueingConsumer;import java.io.IOException;import java.util.concurrent.TimeoutException;/** * @author : JOSE 2018/11/4 10:31 PM */public class Consumer &#123; public static void main(String[] args) throws IOException, TimeoutException, InterruptedException &#123; // 获取channel Connection connection = MqFactory.getConnection(); Channel channel = connection.createChannel(); // 声明一个队列 param1:队列名称 param2:是否持久化 param3:是否独占 param4:是否自动删除 param5:扩展参数 String queueName = \"test001\"; channel.queueDeclare(queueName, true, false, false, null); // 创建消费者 QueueingConsumer consumer = new QueueingConsumer(channel); // 设置channel param1:队列名称 param2: 自动签收 param3:哪一个消费者 channel.basicConsume(queueName, true, consumer); // 获取消息 while (true) &#123; QueueingConsumer.Delivery delivery = consumer.nextDelivery(); byte[] body = delivery.getBody(); System.out.println(\"消费端:\" + new String(body)); &#125; &#125;&#125; 实验结果123456# 消费端消费端:HELLO RabbitMQ:0消费端:HELLO RabbitMQ:1消费端:HELLO RabbitMQ:2消费端:HELLO RabbitMQ:3消费端:HELLO RabbitMQ:4 先启动生产者, 消费者没启动时, 消息积压 ready:5, total:5 启动消费者后, 消息被消费: Exchange 交换机Exchange负责接收消息,并根据路由键转发消息所绑定的队列 交换机的属性: 1.name:交换机名称2.type:交换机的类型,direct,topic,fanout, headers3.durability:是否需要持久化, true表示持久化4.auto delete:当最后一个绑定在Exchange上的队列删除时,自动删除该Exchange5.arguments:扩展参数 交换机的类型—Direct Exchange 1.所有发送到direct exchange的消息被转发到,Routing Key中指定的Queue2.Direct可以使用RabbitMQ自带的Exchange(default Exchange) ,所以不需要将Exchange进行任何的绑定,Routing Key必须完全匹配才会被队列接收 交换机的类型—Topic Exchange 1.Exchange将Routing Key和Topic进行模糊匹配,此时队列需要一个Topic2.”#”:匹配一个或者多个词3.”*”:匹配一个词 交换机的类型—Fanout Exchange 1.不处理路由键,只需要简单的将队列绑定到交换机上, 不处理路由键2.发送到交换机上的消息,都会被转发到与该交换机绑定的所有队列上3.fanout交换机转发消息是最快的 Binding 1.Exchange &amp;&amp; Queue之间的连接关系 Queue 1.消息队列, 存储消息2.Durability:是否持久化3.Auto delete:当最后一个监听被移除的时候, 该队列自动删除 Message 1.Msg服务器和App之间传送的数据2.本质上就是一段数据, 由Properties &amp;&amp; Payload(body) 组成 虚拟主机Virtual Host 1.用于逻辑隔离, 最上层的路由2.一个Virtual Host里面可以有若干个Exchange &amp;&amp; Queue3.同一个Virtual Host里面不可以有相同的Exchange &amp;&amp; Queue","categories":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://www.fireworm.online/categories/RabbitMQ/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://www.fireworm.online/tags/RabbitMQ/"}]},{"title":"JVM(一)---JAVA内存结构","slug":"JVM-一-JAVA内存结构","date":"2018-10-28T05:40:10.000Z","updated":"2018-10-28T07:24:40.920Z","comments":true,"path":"JVM/2018/10/28/JVM-一-JAVA内存结构.html","link":"","permalink":"http://www.fireworm.online/JVM/2018/10/28/JVM-一-JAVA内存结构.html","excerpt":"","text":"JVM概念JDK:Java Development ToolKit(Java开发工具包), JDK是整个JAVA的核心，包括了Java运行环境（Java Runtime Envirnment），一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar） JRE:Java Runtime Enviromental(java运行时环境)。也就是我们说的JAVA平台，所有的Java程序都要在JRE下才能运行。包括JVM和JAVA核心类库和支持文件。与JDK相比，它不包含开发工具——编译器、调试器和其它工具。 JVM:Java Virtual Mechinal(JAVA虚拟机)。JVM是JRE的一部分，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM 的主要工作是解释自己的指令集（即字节码）并映射到本地的 CPU 的指令集或 OS 的系统调用。Java语言是跨平台运行的，其实就是不同的操作系统，使用不同的JVM映射规则，让其与操作系统无关，完成了跨平台性。JVM 对上层的 Java 源文件是不关心的，它关注的只是由源文件生成的类文件（ class file ） JVM的内存结构一.JAVA内存组成 按照官方的说法：“Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。”“在JVM中堆之外的内存称为非堆内存(Non-heap memory)”。可以看出JVM主要管理两种类型的内存：堆和非堆。简单来说堆就是Java代码可及的内存，是留给开发人员使用的；非堆就是JVM留给 自己用的，所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法 的代码都在非堆内存中。 二.内存区域结构 PC寄存器(程序计数器): 是最小的一块内存区域，它的作用是当前线程所执行的字节码的行号指示器，在虚拟机的模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。 Java虚拟机栈: 描述的是java 方法执行的内存模型：每个方法被执行的时候 都会创建一个“栈帧”用于存储局部变量表(包括参数)、操作栈、方法出口等信息。每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。声明周期与线程相同，是线程私有的。局部变量表存放了编译器可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(引用指针，并非对象本身)，其中64位长度的long和double类型的数据会占用2个局部变量的空间，其余数据类型只占1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量是完全确定的，在运行期间栈帧不会改变局部变量表的大小空间。 本地方法栈: 与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的java方法服务，而本地方法栈则是为Native方法服务。 方法区: 也称”永久代” 、“非堆”， 它用于存储虚拟机加载的类信息、常量、静态变量、是各个线程共享的内存区域。默认最小值为16MB，最大值为64MB，可以通过-XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小。运行时常量池：是方法区的一部分，其中的主要内容来自于JVM对Class的加载。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。 堆: 也叫做java 堆、GC堆是java虚拟机所管理的内存中最大的一块内存区域，也是被各个线程共享的内存区域，在JVM启动时创建。该内存区域存放了对象实例及数组(所有new的对象)。其大小通过-Xms(最小值)和-Xmx(最大值)参数设置，-Xms为JVM启动时申请的最小内存，默认为操作系统物理内存的1/64但小于1G，-Xmx为JVM可申请的最大内存，默认为物理内存的1/4但小于1G，默认当空余堆内存小于40%时，JVM会增大Heap到-Xmx指定的大小，可通过-XX:MinHeapFreeRation=来指定这个比列；当空余堆内存大于70%时，JVM会减小heap的大小到-Xms指定的大小，可通过XX:MaxHeapFreeRation=来指定这个比列，对于运行系统，为避免在运行时频繁调整Heap的大小，通常-Xms与-Xmx的值设成一样。 新生代: 程序新创建的对象都是从新生代分配内存，新生代由Eden Space和两块相同大小的Survivor Space(通常又称S0和S1或From和To)构成，可通过-Xmn参数来指定新生代的大小，也可以通过-XX:SurvivorRation来调整Eden Space及Survivor Space的大小。 老年代： 用于存放经过多次新生代GC任然存活的对象，例如缓存对象，新建的对象也有可能直接进入老年代，主要有两种情况：①.大对象，可通过启动参数设置-XX:PretenureSizeThreshold=1024(单位为字节，默认为0)来代表超过多大时就不在新生代分配，而是直接在老年代分配。②.大的数组对象，切数组中无引用外部对象。 老年代所占的内存大小为-Xmx对应的值减去-Xmn对应的值。 12345Young Generation 即图中的Eden + From Space + To SpaceEden 存放新生的对象Survivor Space 有两个，存放每次垃圾回收后存活的对象Old Generation Tenured Generation 即图中的Old Space 主要存放应用程序中生命周期长的存活对象 设置参数: 123451.-Xmn:设置新生代大小 -Xmn10m2.-XX:NewRatio(Ratio of old/new generation sizes): 表示老年代 和 新生代(eden + 2s) 的比值; &gt;XX:NewRatio=4, 表示老年代 / 新生代 = 43.-XX:SurvivorRatio(Ratio of eden/survivor space size eden区域-XX:SurvivorRatio=8 eden/s = 8, 也就是一个s占年轻代的 1/10 加深理解","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.fireworm.online/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.fireworm.online/tags/JVM/"}]}]}